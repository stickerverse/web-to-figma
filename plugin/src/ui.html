<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Web to Figma Converter</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      padding: 24px;
      background: #1a1816;
      color: #e8e6e3;
      line-height: 1.5;
    }

    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 100%;
    }

    /* Header */
    .header {
      text-align: center;
      padding: 16px 0;
    }

    h1 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #e8e6e3;
      letter-spacing: -0.3px;
    }

    .subtitle {
      font-size: 12px;
      color: #a39e98;
      font-weight: 400;
    }

    /* Input Section */
    .input-section {
      background: #2a2623;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #3a3632;
    }

    label {
      display: block;
      font-weight: 500;
      margin-bottom: 10px;
      font-size: 12px;
      color: #c4bfba;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input[type="text"],
    input[type="url"] {
      width: 100%;
      padding: 12px 16px;
      border: 1.5px solid #3a3632;
      border-radius: 8px;
      font-size: 13px;
      font-family: inherit;
      background: #1a1816;
      color: #e8e6e3;
      transition: all 0.2s ease;
    }

    input::placeholder {
      color: #6a6560;
    }

    input:focus {
      outline: none;
      border-color: #7c9885;
      background: #201e1c;
      box-shadow: 0 0 0 3px rgba(124, 152, 133, 0.1);
    }

    /* Buttons */
    .button-group {
      display: flex;
      gap: 12px;
      margin-top: 8px;
    }

    button {
      flex: 1;
      padding: 14px 20px;
      background: #7c9885;
      color: #1a1816;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(124, 152, 133, 0.15);
    }

    button:hover {
      background: #8ba896;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(124, 152, 133, 0.25);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #3a3632;
      color: #6a6560;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.secondary {
      background: transparent;
      border: 1.5px solid #b8876b;
      color: #b8876b;
      box-shadow: none;
    }

    button.secondary:hover {
      background: rgba(184, 135, 107, 0.1);
      border-color: #c79578;
      box-shadow: 0 2px 8px rgba(184, 135, 107, 0.15);
    }

    button.cancel {
      background: transparent;
      border: 1.5px solid #c47864;
      color: #c47864;
      box-shadow: none;
      display: none;
    }

    button.cancel:hover {
      background: rgba(196, 120, 100, 0.1);
      border-color: #d18a76;
    }

    button.cancel.visible {
      display: block;
      flex: 0.5;
    }

    /* Progress Section */
    .progress-section {
      background: #2a2623;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #3a3632;
      display: none;
    }

    .progress-section.visible {
      display: block;
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .progress-label {
      font-size: 12px;
      color: #c4bfba;
      font-weight: 500;
    }

    .progress-percent {
      font-size: 12px;
      color: #7c9885;
      font-weight: 600;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: #1a1816;
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #7c9885 0%, #8ba896 100%);
      transition: width 0.3s ease;
      width: 0%;
      border-radius: 3px;
      box-shadow: 0 0 8px rgba(124, 152, 133, 0.4);
    }

    /* Status */
    .status {
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 12px;
      display: none;
      align-items: center;
      gap: 10px;
    }

    .status.visible {
      display: flex;
    }

    .status.info {
      background: rgba(124, 152, 133, 0.1);
      color: #8ba896;
      border: 1px solid rgba(124, 152, 133, 0.2);
    }

    .status.success {
      background: rgba(107, 148, 120, 0.1);
      color: #6b9478;
      border: 1px solid rgba(107, 148, 120, 0.2);
    }

    .status.error {
      background: rgba(196, 120, 100, 0.1);
      color: #c47864;
      border: 1px solid rgba(196, 120, 100, 0.2);
    }

    .status-icon {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      flex-shrink: 0;
    }

    .status.info .status-icon {
      background: #7c9885;
      color: #1a1816;
    }

    .status.success .status-icon {
      background: #6b9478;
      color: #1a1816;
    }

    .status.error .status-icon {
      background: #c47864;
      color: #1a1816;
    }

    /* Terminal */
    .terminal-section {
      background: #2a2623;
      border-radius: 12px;
      border: 1px solid #3a3632;
      overflow: hidden;
      display: none;
    }

    .terminal-section.visible {
      display: block;
    }

    .terminal-header {
      padding: 12px 16px;
      background: #1a1816;
      color: #a39e98;
      border-bottom: 1px solid #3a3632;
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .terminal-dots {
      display: flex;
      gap: 6px;
    }

    .terminal-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .terminal-dot.red { background: #c47864; }
    .terminal-dot.yellow { background: #b8876b; }
    .terminal-dot.green { background: #7c9885; }

    .terminal-content {
      height: 180px;
      padding: 16px;
      overflow-y: auto;
      line-height: 1.6;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 10px;
    }

    .terminal-content::-webkit-scrollbar {
      width: 6px;
    }

    .terminal-content::-webkit-scrollbar-track {
      background: #1a1816;
    }

    .terminal-content::-webkit-scrollbar-thumb {
      background: #3a3632;
      border-radius: 3px;
    }

    .terminal-content::-webkit-scrollbar-thumb:hover {
      background: #4a4642;
    }

    .terminal-line {
      margin-bottom: 8px;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .terminal-line .timestamp {
      color: #6a6560;
      margin-right: 8px;
    }

    .terminal-line.success { color: #7c9885; }
    .terminal-line.info { color: #8ba896; }
    .terminal-line.warning { color: #b8876b; }
    .terminal-line.error { color: #c47864; }

    /* Preview */
    .preview-section {
      background: #2a2623;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid #3a3632;
      display: none;
    }

    .preview-section.visible {
      display: block;
    }

    .preview-header {
      padding: 12px 16px;
      background: #1a1816;
      font-size: 11px;
      font-weight: 500;
      color: #a39e98;
      border-bottom: 1px solid #3a3632;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .preview-container {
      position: relative;
      height: 140px;
      overflow: hidden;
      background: #1a1816;
    }

    .preview-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: top left;
    }

    .preview-placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #6a6560;
      font-size: 11px;
    }

    .scanner {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg,
        transparent 0%,
        rgba(124, 152, 133, 0.3) 20%,
        rgba(124, 152, 133, 0.8) 50%,
        rgba(124, 152, 133, 0.3) 80%,
        transparent 100%
      );
      box-shadow: 0 0 12px rgba(124, 152, 133, 0.6);
      animation: scan 2s ease-in-out infinite;
      display: none;
    }

    @keyframes scan {
      0% { transform: translateY(0); }
      50% { transform: translateY(137px); }
      100% { transform: translateY(0); }
    }

    .scanner.active {
      display: block;
    }

    /* Examples */
    .examples {
      padding: 20px;
      background: #2a2623;
      border-radius: 12px;
      border: 1px solid #3a3632;
    }

    .example-title {
      font-size: 11px;
      font-weight: 500;
      color: #c4bfba;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .example-link {
      display: block;
      padding: 10px 14px;
      background: #1a1816;
      border: 1px solid #3a3632;
      border-radius: 8px;
      text-decoration: none;
      color: #a39e98;
      font-size: 12px;
      margin-bottom: 8px;
      transition: all 0.2s ease;
    }

    .example-link:hover {
      background: #201e1c;
      border-color: #7c9885;
      color: #e8e6e3;
      transform: translateX(4px);
    }

    .example-link:last-child {
      margin-bottom: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>Web to Figma</h1>
      <div class="subtitle">Maximum Quality â€¢ 95-100% Accuracy</div>
    </div>

    <!-- Input Section -->
    <div class="input-section">
      <label for="url">Website URL</label>
      <input
        type="url"
        id="url"
        placeholder="https://example.com"
        value="https://stripe.com"
      />

      <div class="button-group">
        <button id="import-btn">Start Import</button>
        <button class="cancel" id="cancel-btn">Cancel</button>
      </div>
    </div>

    <!-- Progress Section -->
    <div class="progress-section" id="progress-section">
      <div class="progress-header">
        <span class="progress-label" id="progress-label">Initializing...</span>
        <span class="progress-percent" id="progress-percent">0%</span>
      </div>
      <div class="progress-bar">
        <div class="progress-bar-fill" id="progress-fill"></div>
      </div>
    </div>

    <!-- Status -->
    <div class="status" id="status">
      <div class="status-icon" id="status-icon">i</div>
      <div class="status-text" id="status-text"></div>
    </div>

    <!-- Preview Section -->
    <div class="preview-section" id="preview-section">
      <div class="preview-header">Website Preview</div>
      <div class="preview-container">
        <div class="preview-placeholder" id="preview-placeholder">
          Capturing screenshot...
        </div>
        <img class="preview-image" id="preview-image" style="display: none;">
        <div class="scanner" id="scanner"></div>
      </div>
    </div>

    <!-- Terminal Log Section -->
    <div class="terminal-section" id="terminal-section">
      <div class="terminal-header">
        <div class="terminal-dots">
          <div class="terminal-dot red"></div>
          <div class="terminal-dot yellow"></div>
          <div class="terminal-dot green"></div>
        </div>
        <span>Extraction Log</span>
      </div>
      <div class="terminal-content" id="terminal-content"></div>
    </div>

    <!-- Quick Examples -->
    <div class="examples">
      <div class="example-title">Quick Test Sites</div>
      <a href="#" class="example-link" data-url="https://stripe.com">Stripe</a>
      <a href="#" class="example-link" data-url="https://tailwindcss.com">Tailwind CSS</a>
      <a href="#" class="example-link" data-url="https://github.com">GitHub</a>
    </div>
  </div>

  <script>
    const urlInput = document.getElementById('url');
    const importBtn = document.getElementById('import-btn');
    const cancelBtn = document.getElementById('cancel-btn');
    const statusDiv = document.getElementById('status');
    const statusIcon = document.getElementById('status-icon');
    const statusText = document.getElementById('status-text');
    const progressSection = document.getElementById('progress-section');
    const progressLabel = document.getElementById('progress-label');
    const progressPercent = document.getElementById('progress-percent');
    const progressFill = document.getElementById('progress-fill');
    const exampleLinks = document.querySelectorAll('.example-link');
    const previewSection = document.getElementById('preview-section');
    const previewImage = document.getElementById('preview-image');
    const previewPlaceholder = document.getElementById('preview-placeholder');
    const scanner = document.getElementById('scanner');
    const terminalSection = document.getElementById('terminal-section');
    const terminalContent = document.getElementById('terminal-content');

    let currentWebSocket = null;
    let isImporting = false;
    let lastKeepAliveLog = 0;
    let cachedServerPort = null;
    let pendingServerPortPromise = null;

    // Example link clicks
    exampleLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        urlInput.value = link.dataset.url;
      });
    });

    // Cancel button
    cancelBtn.addEventListener('click', () => {
      if (currentWebSocket) {
        currentWebSocket.close();
        currentWebSocket = null;
      }
      resetUI();
      showStatus('Import cancelled', 'error');
      addTerminalLog('âš  Import cancelled by user', 'warning');
    });

    function resetUI() {
      isImporting = false;
      lastKeepAliveLog = 0;
      importBtn.disabled = false;
      importBtn.textContent = 'Start Import';
      cancelBtn.classList.remove('visible');
      progressSection.classList.remove('visible');
      progressFill.style.width = '0%';
      scanner.classList.remove('active');
    }

    function updateProgress(percent, label) {
      progressFill.style.width = percent + '%';
      progressPercent.textContent = Math.round(percent) + '%';
      if (label) {
        progressLabel.textContent = label;
      }
    }

    function addTerminalLog(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString('en-US', {
        hour12: false,
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });

      const line = document.createElement('div');
      line.className = `terminal-line ${type}`;
      line.innerHTML = `<span class="timestamp">[${timestamp}]</span>${message}`;

      terminalContent.appendChild(line);
      terminalContent.scrollTop = terminalContent.scrollHeight;
    }

    function clearTerminal() {
      terminalContent.innerHTML = '';
    }

    function preparePreview() {
      previewSection.classList.add('visible');
      terminalSection.classList.add('visible');
      scanner.classList.add('active');
      previewImage.style.display = 'none';
      previewPlaceholder.style.display = 'flex';
    }

    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function capturePreview(url, serverPort) {
      setTimeout(async () => {
        if (!isImporting) {
          return;
        }
        try {
          const screenshotUrl = `http://localhost:${serverPort}/screenshot?url=${encodeURIComponent(url)}`;
          const response = await fetch(screenshotUrl);
          const data = await response.json();

          const screenshotSrc = data.screenshot?.src ?? data.screenshot;
          if (screenshotSrc) {
            previewImage.src = screenshotSrc;
            previewImage.style.display = 'block';
            previewPlaceholder.style.display = 'none';
            addTerminalLog('âœ“ Website preview captured', 'success');
          }
        } catch (error) {
          addTerminalLog(`âš  Preview capture failed: ${error.message}`, 'warning');
        }
      }, 750);
    }

    async function getServerPort(options = {}) {
      if (cachedServerPort !== null) {
        return cachedServerPort;
      }

      if (pendingServerPortPromise) {
        return pendingServerPortPromise;
      }

      pendingServerPortPromise = (async () => {
        const port = await discoverServerPort(options);
        cachedServerPort = port;
        return port;
      })();

      try {
        return await pendingServerPortPromise;
      } finally {
        pendingServerPortPromise = null;
      }
    }

    function createTimeoutSignal(timeoutMs) {
      if (typeof AbortSignal !== 'undefined' && typeof AbortSignal.timeout === 'function') {
        return {
          signal: AbortSignal.timeout(timeoutMs),
          cleanup: () => {}
        };
      }

      if (typeof AbortController === 'undefined') {
        return {
          signal: undefined,
          cleanup: () => {}
        };
      }

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

      return {
        signal: controller.signal,
        cleanup: () => clearTimeout(timeoutId)
      };
    }

    async function discoverServerPort({ logAttempts = false } = {}) {
      const possiblePorts = [3000, 3001, 3002, 3003, 3004];
      const maxAttempts = 5;
      const attemptDelayMs = 500;
      let lastError = null;

      for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
        if (logAttempts) {
          addTerminalLog(`ðŸ” Looking for scraper server (attempt ${attempt}/${maxAttempts})`, 'info');
        }

        for (const port of possiblePorts) {
          const { signal, cleanup } = createTimeoutSignal(1000);

          try {
            const response = await fetch(`http://localhost:${port}/health`, {
              method: 'GET',
              signal
            });

            if (response?.ok) {
              cachedServerPort = port;
              return port;
            }
          } catch (error) {
            lastError = error;
            // Port not available, try next
          } finally {
            cleanup();
          }
        }

        if (attempt < maxAttempts) {
          await wait(attemptDelayMs);
        }
      }

      const reason = lastError?.message ? ` Last error: ${lastError.message}` : '';
      throw new Error(`No running server found on ports 3000-3004 after multiple attempts.${reason}`);
    }

    // Import button
    importBtn.addEventListener('click', async () => {
      const url = urlInput.value.trim();

      if (!url) {
        showStatus('Please enter a URL', 'error');
        return;
      }

      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        showStatus('URL must start with http:// or https://', 'error');
        return;
      }

      isImporting = true;
      importBtn.disabled = true;
      importBtn.textContent = 'Importing...';
      cancelBtn.classList.add('visible');
      progressSection.classList.add('visible');
      updateProgress(0, 'Initializing...');

      clearTerminal();
      preparePreview();

      addTerminalLog('ðŸš€ Starting web-to-figma conversion', 'info');
      addTerminalLog(`ðŸ“„ Target: ${url}`, 'info');

      showStatus('Discovering server...', 'info');

      let serverPort;
      try {
        serverPort = await getServerPort({ logAttempts: true });
        if (!isImporting) {
          return;
        }
        showStatus(`Connected to server on port ${serverPort}`, 'success');
        addTerminalLog(`âœ“ Connected to server on port ${serverPort}`, 'success');
        capturePreview(url, serverPort);
      } catch (error) {
        showStatus('Server not found. Please start the scraper server first.', 'error');
        addTerminalLog('âœ— Server connection failed', 'error');
        resetUI();
        return;
      }

      // Connect via WebSocket
      try {
        const ws = new WebSocket(`ws://localhost:${serverPort}/ws`);
        currentWebSocket = ws;

        ws.onopen = () => {
          updateProgress(5, 'Connected to server');
          showStatus('Extracting website...', 'info');
          parent.postMessage({
            pluginMessage: {
              type: 'server_config',
              serverPort: serverPort
            }
          }, '*');
          ws.send(JSON.stringify({ url, mode: 'maximum' }));
        };

        ws.onmessage = (event) => {
          const message = JSON.parse(event.data);

          const forward = () => {
            parent.postMessage({ pluginMessage: message }, '*');
          };

          switch (message.type) {
            case 'TOKENS':
              updateProgress(20, 'Creating tokens');
              addTerminalLog('âœ“ Tokens extracted', 'success');
              forward();
              break;

            case 'FONTS':
              updateProgress(30, `Loading ${message.payload?.length || 0} fonts`);
              addTerminalLog(`âœ“ ${message.payload?.length || 0} fonts loaded`, 'success');
              forward();
              break;

            case 'NODES':
              updateProgress(50, 'Streaming nodes');
              forward();
              break;

            case 'IMAGE_CHUNK':
              forward();
              break;

            case 'LOG':
              // Display log message in terminal
              const log = message.payload;
              if (log && log.message) {
                const levelMap = {
                  'info': 'info',
                  'success': 'success',
                  'warning': 'warning',
                  'error': 'error'
                };
                const level = levelMap[log.level] || 'info';
                addTerminalLog(log.message, level);
              }
              break;

            case 'PROGRESS':
              const stage = message.payload?.stage;
              const progressMessage = message.payload?.message;

              // Update terminal with progress message
              if (progressMessage) {
                addTerminalLog(progressMessage, 'info');
              }

              if (stage === 'heartbeat') {
                const now = Date.now();
                if (now - lastKeepAliveLog > 15000) {
                  addTerminalLog('â³ Extraction still running...', 'info');
                  lastKeepAliveLog = now;
                }
              }

              if (stage === 'processing_images') {
                const percent = 30 + Math.min(40, Math.round((message.payload.current / message.payload.total) * 40));
                updateProgress(percent, `Processing images ${message.payload.current}/${message.payload.total}`);
              } else if (stage === 'streaming_images') {
                const percent = 70 + Math.min(20, Math.round((message.payload.current / message.payload.total) * 20));
                updateProgress(percent, `Streaming images ${message.payload.current}/${message.payload.total}`);
              } else if (stage === 'streaming_nodes') {
                const percent = 50 + Math.min(20, Math.round((message.payload.current / message.payload.total) * 20));
                updateProgress(percent, `Streaming nodes ${message.payload.current}/${message.payload.total}`);
              }
              forward();
              break;

            case 'COMPLETE':
              updateProgress(100, 'Complete!');
              showStatus('âœ“ Import complete!', 'success');
              addTerminalLog('âœ“ Import complete!', 'success');
              forward();
              setTimeout(() => {
                resetUI();
              }, 2000);
              ws.close();
              break;

            case 'ERROR':
              showStatus('Error: ' + (message.payload?.message || message.error || 'Unknown error'), 'error');
              addTerminalLog(`âœ— Error: ${message.payload?.message || message.error}`, 'error');
              forward();
              resetUI();
              ws.close();
              break;

            default:
              forward();
              break;
          }
        };

        ws.onerror = () => {
          showStatus('Connection failed', 'error');
          addTerminalLog('âœ— WebSocket connection failed', 'error');
          cachedServerPort = null;
          resetUI();
        };

        ws.onclose = (event) => {
          if (isImporting) {
            showStatus('Connection closed', 'error');
            resetUI();
          }
          if (event && event.code !== 1000) {
            cachedServerPort = null;
          }
          currentWebSocket = null;
        };

      } catch (error) {
        showStatus('Failed to connect: ' + error.message, 'error');
        addTerminalLog(`âœ— Connection error: ${error.message}`, 'error');
        resetUI();
      }
    });

    function showStatus(message, type) {
      statusText.textContent = message;
      statusDiv.className = `status ${type} visible`;

      const icons = { info: 'i', success: 'âœ“', error: 'âœ—', warning: 'âš ' };
      statusIcon.textContent = icons[type] || 'i';
    }
  </script>
</body>
</html>
